import cv2 as cv
import numpy as np
import random as r
from collections import deque
import math as m

def get_ortho_vector( x, y):
	
	# xi * x + yi * y = 0
	#1 * x + yi * y = 0
	#yi = (-x) / y
	xi = 1
	yi = float(-x) / y
	
	length = m.sqrt( xi* xi + yi * yi)

	return xi/length , yi/length

def normalize_vec( x, y):
	length = m.sqrt( x* x + y * y)
	
	return x/length, y/length

r.seed()

height = 600
width = 1200
seed_count = 5

inertia_ratio = 0.75

aux_count =0 
slate = np.zeros((height,width,3), np.uint8)

# lista de pontos, x, y, color, senoidal_counter, direction_0
point_list = deque()

branching_factor = 3

branching_speed = 80

kernel_size = 20
step_line_length = 3

senoidal_distance = 0
senoidal_update = 1

for i in range(seed_count):
	point_list.append(( r.randint(kernel_size, width-kernel_size-1), r.randint(kernel_size, height-kernel_size-1), (0, 190+i, 200), 90 , (r.random() - r.random(), r.random() - r.random()), branching_factor, 0))
	#point_list.append(( width//2, height//2, (0, 190+i, 200), 90 , (r.random() - r.random(), r.random() - r.random()), branching_factor, 0))
print(len(point_list))	
# cada pontos, x, y, color, senoidal_counter, direction_0

while point_list:

	x, y, (h, s, v), sen_counter, direction, branches, branching_timer  = point_list.popleft()
	
	# crops the kernel window
	if branching_timer >= branching_speed and branches > 0:
		branching_timer = 0
		branches -= 1
		point_list.append( (x, y , ((h+1)%360, s - seed_count, v), sen_counter+senoidal_update, direction, branches, 0) )

	# new direction
	if  kernel_size < x < width - kernel_size and kernel_size < y < height - kernel_size : 
		direction_alpha = (0, 0)
		for xi in range(x-kernel_size+1, x+kernel_size-1 ):
			for yi in range( y-kernel_size+1, y+kernel_size-1):
			
				ph, ps, pv = slate[yi, xi]
				
				# vefifies whether xi, yi was generated by this seed
				if ps == s or ps == 0:
					continue
				
				if xi == kernel_size and yi == kernel_size:
					continue
				
				distance = m.sqrt( xi* xi + yi*yi)
				
				x_ = (x - xi) / (distance * distance)
				y_ = (y - yi) / (distance * distance)
				
				direction_alpha = ((direction_alpha[0] + x_) , ( direction_alpha[1] + y_))
		
		direction_alpha_length = m.sqrt( direction_alpha[0]*direction_alpha[0] + direction_alpha[1]*direction_alpha[1])
		if direction_alpha_length != 0:
			direction_alpha = (direction_alpha[0]/direction_alpha_length, direction_alpha[1]/direction_alpha_length)
		
		direction = normalize_vec(direction[0]*inertia_ratio + direction_alpha[0]*(1-inertia_ratio), (direction[1]*inertia_ratio + direction_alpha[1]*(1-inertia_ratio)))
		
		ortho_direction = get_ortho_vector(*direction)
		
		x_n = x + (direction[0] * step_line_length) + m.cos(sen_counter) * senoidal_distance * ortho_direction[0]
		y_n = y + (direction[1] * step_line_length) + m.cos(sen_counter) * senoidal_distance * ortho_direction[1]
		
		
		if  kernel_size < x < width - kernel_size and kernel_size < y < height - kernel_size : 
			cv.line(slate, (int(x), int(y)), ( int(x_n) , int(y_n)), (h, s, v))
			point_list.append( (int(x_n), int(y_n) , ((h+1)%360, s, v), sen_counter+senoidal_update, direction, branches, (branching_timer+1) ) )
			
	
		#if aux_count % 50 == 0:
	hsv = cv.cvtColor(slate, cv.COLOR_HSV2BGR)
	cv.imshow("window", hsv)
	cv.waitKey(1)
		
	aux_count+=1	
	
hsv = cv.cvtColor(slate, cv.COLOR_HSV2BGR)
cv.imshow("window", hsv)
cv.waitKey(0)